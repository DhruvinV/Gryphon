/*
* Copyright 2018 VinÃ­cius Jorge Vendramini
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
%{
astNodes = [
	['expression', [['expression', 'GRYExpression']]],
	['extensionDeclaration', [['type', 'String'], ['members', '[GRYTopLevelNode]']]],
	['importDeclaration', [['name', 'String']]],
	['classDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[GRYTopLevelNode]']]],
	['companionObject', [['members', '[GRYTopLevelNode]']]],
	['enumDeclaration',
		[['access', 'String?'], ['name', 'String'], ['inherits', '[String]'],
		['elements', '[GRYTopLevelNode]']]],
	['enumElementDeclaration',
		[['name', 'String'], ['associatedValueLabels', '[String]'],
		['associatedValueTypes', '[String]']]],
	['protocolDeclaration', [['name', 'String'], ['members', '[GRYTopLevelNode]']]],
	['structDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[GRYTopLevelNode]']]],
	['functionDeclaration',
		[['prefix', 'String'], ['parameterNames', '[String]'], ['parameterTypes', '[String]'],
		['defaultValues', '[GRYExpression?]'], ['returnType', 'String'], ['isImplicit', 'Bool'],
		['isStatic', 'Bool'], ['isMutating', 'Bool'], ['extendsType', 'String?'],
		['statements', '[GRYTopLevelNode]?'], ['access', 'String?']]],
	['variableDeclaration',
		[['identifier', 'String'], ['typeName', 'String'], ['expression', 'GRYExpression?'],
		['getter', 'GRYTopLevelNode?'], ['setter', 'GRYTopLevelNode?'], ['isLet', 'Bool'],
		['extendsType', 'String?'], ['annotations', 'String?']]],
	['forEachStatement',
		[['collection', 'GRYExpression'], ['variable', 'GRYExpression'],
		['statements', '[GRYTopLevelNode]']]],
	['ifStatement',
		[['conditions', '[GRYExpression]'], ['declarations', '[GRYTopLevelNode]'],
		['statements', '[GRYTopLevelNode]'], ['elseStatement', 'GRYTopLevelNode?'],
		['isGuard', 'Bool']]],
	['throwStatement', [['expression', 'GRYExpression']]],
	['returnStatement', [['expression', 'GRYExpression?']]],
	['assignmentStatement', [['leftHand', 'GRYExpression'], ['rightHand', 'GRYExpression']]],
	['error'],
	]
}%

public indirect enum GRYTopLevelNode: Equatable, GRYPrintableAsTree {

%for astNode in astNodes:
%	name = astNode[0]
%
%	if len(astNode) > 1:
%		pairs = astNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end

	//
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: self.name)

		switch self {
%for astNode in astNodes:
%	name = astNode[0]
%
%	if len(astNode) > 1:
%		pairs = astNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
		case let .${name}(
				${parametersString}):
%		for pair in pairs:
			try ${pair[0]}.encode(into: encoder)
%		end
%
%	else:
		case .${name}:
			break
%	end
%end
		}

		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> GRYTopLevelNode {
		try decoder.readOpeningParenthesis()
		let name = decoder.readDoubleQuotedString()

		let result: GRYTopLevelNode

		switch name {
%for astNode in astNodes:
%	name = astNode[0]
%
		case "${name}":
%
%	if len(astNode) > 1:
%		pairs = astNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
			let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
			result = .${name}(
				${parametersString})
%
%	else:
			result = .${name}
%	end
%end
		default:
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder, errorMessage: "Unknown GRYTopLevelNode \"\(name)\".")
		}

		try decoder.readClosingParenthesis()
		return result
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
%{
expressionNodes = [
	['literalCodeExpression', [['string', 'String']]],
	['templateExpression', [['pattern', 'String'], ['matches', '[String: GRYExpression]']]],
	['parenthesesExpression', [['expression', 'GRYExpression']]],
	['forceValueExpression', [['expression', 'GRYExpression']]],
	['optionalExpression', [['expression', 'GRYExpression']]],
	['declarationReferenceExpression', [['identifier', 'String'], ['type', 'String'],
		['isStandardLibrary', 'Bool'], ['isImplicit', 'Bool']]],
	['typeExpression', [['type', 'String']]],
	['subscriptExpression',
		[['subscriptedExpression', 'GRYExpression'], ['indexExpression', 'GRYExpression'],
		['type', 'String']]],
	['arrayExpression', [['elements', '[GRYExpression]'], ['type', 'String']]],
	['dotExpression',
		[['leftExpression', 'GRYExpression'], ['rightExpression', 'GRYExpression']]],
	['binaryOperatorExpression',
		[['leftExpression', 'GRYExpression'], ['rightExpression', 'GRYExpression'],
		['operatorSymbol', 'String'], ['type', 'String']]],
	['prefixUnaryExpression',
		[['expression', 'GRYExpression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['postfixUnaryExpression',
		[['expression', 'GRYExpression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['callExpression',
		[['function', 'GRYExpression'], ['parameters', 'GRYExpression'], ['type', 'String']]],
	['closureExpression',
		[['parameterNames', '[String]'], ['parameterTypes', '[String]'],
		['statements', '[GRYTopLevelNode]'], ['type', 'String']]],
	['literalIntExpression', [['value', 'Int']]],
	['literalDoubleExpression', [['value', 'Double']]],
	['literalBoolExpression', [['value', 'Bool']]],
	['literalStringExpression', [['value', 'String']]],
	['nilLiteralExpression'],
	['interpolatedStringLiteralExpression', [['expressions', '[GRYExpression]']]],
	['tupleExpression', [['pairs', '[TuplePair]']]],
	['error'],
]
}%

public indirect enum GRYExpression: Equatable, GRYPrintableAsTree {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end

	//
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: self.name)

		switch self {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
		case let .${name}(
				${parametersString}):
%		for pair in pairs:
			try ${pair[0]}.encode(into: encoder)
%		end
%
%	else:
		case .${name}:
			break
%	end
%end
		}

		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> GRYExpression {
		try decoder.readOpeningParenthesis()
		let name = decoder.readDoubleQuotedString()

		let result: GRYExpression

		switch name {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
		case "${name}":
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
			let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
			result = .${name}(
				${parametersString})
%
%	else:
			result = .${name}
%	end
%end
		default:
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder, errorMessage: "Unknown GRYExpression \"\(name)\".")
		}

		try decoder.readClosingParenthesis()
		return result
	}
}
