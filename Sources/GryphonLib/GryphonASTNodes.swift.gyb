/*
* Copyright 2018 VinÃ­cius Jorge Vendramini
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// TODO: ifStatement.elseStatement should be IfStatement
%{
statementNodes = [
	['expression', [['expression', 'Expression']]],
	['typealiasDeclaration',
		[['identifier', 'String'], ['type', 'String'], ['isImplicit', 'Bool']]],
	['extensionDeclaration', [['type', 'String'], ['members', '[Statement]']]],
	['importDeclaration', [['name', 'String']]],
	['classDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[Statement]']]],
	['companionObject', [['members', '[Statement]']]],
	['enumDeclaration',
		[['access', 'String?'], ['name', 'String'], ['inherits', '[String]'],
		['elements', '[EnumElement]'], ['members', '[Statement]'],
		['isImplicit', 'Bool']]],
	['protocolDeclaration', [['name', 'String'], ['members', '[Statement]']]],
	['structDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[Statement]']]],
	['functionDeclaration',
		[['value', 'FunctionDeclaration']]],
	['variableDeclaration',
		[['value', 'VariableDeclaration']]],
	['forEachStatement',
		[['collection', 'Expression'], ['variable', 'Expression'],
		['statements', '[Statement]']]],
	['ifStatement',
		[['value', 'IfStatement']]],
	['switchStatement',
		[['convertsToExpression', 'Statement?'], ['expression', 'Expression'],
		['cases', '[SwitchCase]']]],
	['throwStatement', [['expression', 'Expression']]],
	['returnStatement', [['expression', 'Expression?']]],
	['assignmentStatement', [['leftHand', 'Expression'], ['rightHand', 'Expression']]],
	['error'],
	]
}%

public indirect enum Statement: Equatable, PrintableAsTree {

%for statementNode in statementNodes:
%	name = statementNode[0]
%
%	if len(statementNode) > 1:
%		pairs = statementNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end

	//
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: self.name)

		switch self {
%for statementNode in statementNodes:
%	name = statementNode[0]
%
%	if len(statementNode) > 1:
%		pairs = statementNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
		case let .${name}(
				${parametersString}):
%		for pair in pairs:
			try ${pair[0]}.encode(into: encoder)
%		end
%
%	else:
		case .${name}:
			break
%	end
%end
		}

		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> Statement {
		try decoder.readOpeningParenthesis()
		let name = decoder.readDoubleQuotedString()

		let result: Statement

		switch name {
%for statementNode in statementNodes:
%	name = statementNode[0]
%
		case "${name}":
%
%	if len(statementNode) > 1:
%		pairs = statementNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
			let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
			result = .${name}(
				${parametersString})
%
%	else:
			result = .${name}
%	end
%end
		default:
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder, errorMessage: "Unknown Statement \"\(name)\".")
		}

		try decoder.readClosingParenthesis()
		return result
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// TODO: dictionaryExpression should have key-value pairs
%{
expressionNodes = [
	['literalCodeExpression', [['string', 'String']]],
	['literalDeclarationExpression', [['string', 'String']]],
	['templateExpression', [['pattern', 'String'], ['matches', '[String: Expression]']]],
	['parenthesesExpression', [['expression', 'Expression']]],
	['forceValueExpression', [['expression', 'Expression']]],
	['optionalExpression', [['expression', 'Expression']]],
	['declarationReferenceExpression', [['identifier', 'String'], ['type', 'String'],
		['isStandardLibrary', 'Bool'], ['isImplicit', 'Bool']]],
	['typeExpression', [['type', 'String']]],
	['subscriptExpression',
		[['subscriptedExpression', 'Expression'], ['indexExpression', 'Expression'],
		['type', 'String']]],
	['arrayExpression', [['elements', '[Expression]'], ['type', 'String']]],
	['dictionaryExpression', [['keys', '[Expression]'], ['values', '[Expression]'],
		['type', 'String']]],
	['dotExpression',
		[['leftExpression', 'Expression'], ['rightExpression', 'Expression']]],
	['binaryOperatorExpression',
		[['leftExpression', 'Expression'], ['rightExpression', 'Expression'],
		['operatorSymbol', 'String'], ['type', 'String']]],
	['prefixUnaryExpression',
		[['expression', 'Expression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['postfixUnaryExpression',
		[['expression', 'Expression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['callExpression',
		[['function', 'Expression'], ['parameters', 'Expression'], ['type', 'String']]],
	['closureExpression',
		[['parameters', '[LabeledType]'], ['statements', '[Statement]'],
		['type', 'String']]],
	['literalIntExpression', [['value', 'Int64']]],
	['literalUIntExpression', [['value', 'UInt64']]],
	['literalDoubleExpression', [['value', 'Double']]],
	['literalFloatExpression', [['value', 'Float']]],
	['literalBoolExpression', [['value', 'Bool']]],
	['literalStringExpression', [['value', 'String']]],
	['nilLiteralExpression'],
	['interpolatedStringLiteralExpression', [['expressions', '[Expression]']]],
	['tupleExpression', [['pairs', '[LabeledExpression]']]],
	['tupleShuffleExpression',
		[['labels', '[String]'], ['indices', '[TupleShuffleIndex]'],
		['expressions', '[Expression]']]],
	['error'],
]
}%

public indirect enum Expression: Equatable, PrintableAsTree {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end

	//
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: self.name)

		switch self {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
		case let .${name}(
				${parametersString}):
%		for pair in pairs:
			try ${pair[0]}.encode(into: encoder)
%		end
%
%	else:
		case .${name}:
			break
%	end
%end
		}

		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> Expression {
		try decoder.readOpeningParenthesis()
		let name = decoder.readDoubleQuotedString()

		let result: Expression

		switch name {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
		case "${name}":
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
			let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
			result = .${name}(
				${parametersString})
%
%	else:
			result = .${name}
%	end
%end
		default:
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder, errorMessage: "Unknown Expression \"\(name)\".")
		}

		try decoder.readClosingParenthesis()
		return result
	}
}
%{
astElements = [
	['struct', 'LabeledExpression',
		[['label', 'String?'], ['expression', 'Expression']]],
	['struct', 'LabeledType',
		[['label', 'String'], ['type', 'String']]],
	['struct', 'FunctionParameter',
		[['label', 'String'], ['apiLabel', 'String?'], ['type', 'String'],
		['value', 'Expression?']]],
	['struct', 'VariableDeclaration',
		[['identifier', 'String'], ['typeName', 'String'], ['expression', 'Expression?'],
		['getter', 'Statement?'], ['setter', 'Statement?'], ['isLet', 'Bool'],
		['isImplicit', 'Bool'], ['isStatic', 'Bool'], ['extendsType', 'String?'],
		['annotations', 'String?']]],
	['struct', 'FunctionDeclaration',
		[['prefix', 'String'], ['parameters', '[FunctionParameter]'],
		['returnType', 'String'], ['functionType', 'String'], ['isImplicit', 'Bool'],
		['isStatic', 'Bool'], ['isMutating', 'Bool'], ['extendsType', 'String?'],
		['statements', '[Statement]?'], ['access', 'String?']]],
	['class', 'IfStatement',
		[['conditions', '[Expression]'], ['declarations', '[VariableDeclaration]'],
		['statements', '[Statement]'], ['elseStatement', 'IfStatement?'],
		['isGuard', 'Bool']]],
	['struct', 'SwitchCase',
		[['expression', 'Expression?'], ['statements', '[Statement]']]],
	['struct', 'EnumElement',
		[['name', 'String'], ['associatedValues', '[LabeledType]'],
		['annotations', 'String?']]],
	]
}%
%for astElement in astElements:
%	keyword = astElement[0]
%	name = astElement[1]
%	pairs = astElement[2]

public ${keyword} ${name}: Equatable {
%	for pair in pairs:
	var ${pair[0]}: ${pair[1]}
%	end

%	if keyword == 'class':
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	public init(
		${parametersString})
	{
%		for pair in pairs:
		self.${pair[0]} = ${pair[0]}
%		end
	}

	public static func == (lhs: IfStatement, rhs: IfStatement) -> Bool {
%		equalityChecks = []
%		for pair in pairs:
%			equalityChecks.append("lhs." + pair[0] + " == " + "rhs." + pair[0])
%		end
%		equalityChecksString = " &&\n\t\t\t".join(equalityChecks)
		return ${equalityChecksString}
	}

	public func copy() -> IfStatement {
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t".join(parameters)
		return IfStatement(
			${parametersString})
	}

%	end
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: "${name}")
%	for pair in pairs:
		try ${pair[0]}.encode(into: encoder)
%	end
		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> ${name} {
		try decoder.readOpeningParenthesis()
		let objectName = decoder.readDoubleQuotedString()
		guard objectName == "${name}" else {
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder,
				errorMessage: "Attempted to decode a \(objectName) as a '${name}'.")
		}

%		for pair in pairs:
		let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end

		try decoder.readClosingParenthesis()

		return ${name}(
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t".join(parameters)
			${parametersString})
	}
}
%end
