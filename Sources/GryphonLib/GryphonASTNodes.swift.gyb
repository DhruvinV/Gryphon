/*
* Copyright 2018 VinÃ­cius Jorge Vendramini
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// TODO: See if this still needs to be in a separate file
// TODO: ifStatement.elseStatement should be IfStatement
%{
statementNodes = [
	['expression', [['expression', 'Expression']]],
	['typealiasDeclaration',
		[['identifier', 'String'], ['type', 'String'], ['isImplicit', 'Bool']]],
	['extensionDeclaration', [['type', 'String'], ['members', '[Statement]']]],
	['importDeclaration', [['name', 'String']]],
	['classDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[Statement]']]],
	['companionObject', [['members', '[Statement]']]],
	['enumDeclaration',
		[['access', 'String?'], ['name', 'String'], ['inherits', '[String]'],
		['elements', '[EnumElement]'], ['members', '[Statement]'],
		['isImplicit', 'Bool']]],
	['protocolDeclaration', [['name', 'String'], ['members', '[Statement]']]],
	['structDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[Statement]']]],
	['functionDeclaration',
		[['value', 'FunctionDeclaration']]],
	['variableDeclaration',
		[['value', 'VariableDeclaration']]],
	['forEachStatement',
		[['collection', 'Expression'], ['variable', 'Expression'],
		['statements', '[Statement]']]],
	['ifStatement',
		[['value', 'IfStatement']]],
	['switchStatement',
		[['convertsToExpression', 'Statement?'], ['expression', 'Expression'],
		['cases', '[SwitchCase]']]],
	['throwStatement', [['expression', 'Expression']]],
	['returnStatement', [['expression', 'Expression?']]],
	['assignmentStatement', [['leftHand', 'Expression'], ['rightHand', 'Expression']]],
	['error'],
	]
}%

public indirect enum Statement: Equatable, PrintableAsTree {

%for statementNode in statementNodes:
%	name = statementNode[0]
%
%	if len(statementNode) > 1:
%		pairs = statementNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// TODO: dictionaryExpression should have key-value pairs
%{
expressionNodes = [
	['literalCodeExpression', [['string', 'String']]],
	['literalDeclarationExpression', [['string', 'String']]],
	['templateExpression', [['pattern', 'String'], ['matches', '[String: Expression]']]],
	['parenthesesExpression', [['expression', 'Expression']]],
	['forceValueExpression', [['expression', 'Expression']]],
	['optionalExpression', [['expression', 'Expression']]],
	['declarationReferenceExpression', [['identifier', 'String'], ['type', 'String'],
		['isStandardLibrary', 'Bool'], ['isImplicit', 'Bool']]],
	['typeExpression', [['type', 'String']]],
	['subscriptExpression',
		[['subscriptedExpression', 'Expression'], ['indexExpression', 'Expression'],
		['type', 'String']]],
	['arrayExpression', [['elements', '[Expression]'], ['type', 'String']]],
	['dictionaryExpression', [['keys', '[Expression]'], ['values', '[Expression]'],
		['type', 'String']]],
	['dotExpression',
		[['leftExpression', 'Expression'], ['rightExpression', 'Expression']]],
	['binaryOperatorExpression',
		[['leftExpression', 'Expression'], ['rightExpression', 'Expression'],
		['operatorSymbol', 'String'], ['type', 'String']]],
	['prefixUnaryExpression',
		[['expression', 'Expression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['postfixUnaryExpression',
		[['expression', 'Expression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['callExpression',
		[['function', 'Expression'], ['parameters', 'Expression'], ['type', 'String']]],
	['closureExpression',
		[['parameters', '[LabeledType]'], ['statements', '[Statement]'],
		['type', 'String']]],
	['literalIntExpression', [['value', 'Int64']]],
	['literalUIntExpression', [['value', 'UInt64']]],
	['literalDoubleExpression', [['value', 'Double']]],
	['literalFloatExpression', [['value', 'Float']]],
	['literalBoolExpression', [['value', 'Bool']]],
	['literalStringExpression', [['value', 'String']]],
	['nilLiteralExpression'],
	['interpolatedStringLiteralExpression', [['expressions', '[Expression]']]],
	['tupleExpression', [['pairs', '[LabeledExpression]']]],
	['tupleShuffleExpression',
		[['labels', '[String]'], ['indices', '[TupleShuffleIndex]'],
		['expressions', '[Expression]']]],
	['error'],
]
}%

public indirect enum Expression: Equatable, PrintableAsTree {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end
}
%{
astElements = [
	['struct', 'LabeledExpression',
		[['label', 'String?'], ['expression', 'Expression']]],
	['struct', 'LabeledType',
		[['label', 'String'], ['type', 'String']]],
	['struct', 'FunctionParameter',
		[['label', 'String'], ['apiLabel', 'String?'], ['type', 'String'],
		['value', 'Expression?']]],
	['struct', 'VariableDeclaration',
		[['identifier', 'String'], ['typeName', 'String'], ['expression', 'Expression?'],
		['getter', 'Statement?'], ['setter', 'Statement?'], ['isLet', 'Bool'],
		['isImplicit', 'Bool'], ['isStatic', 'Bool'], ['extendsType', 'String?'],
		['annotations', 'String?']]],
	['struct', 'FunctionDeclaration',
		[['prefix', 'String'], ['parameters', '[FunctionParameter]'],
		['returnType', 'String'], ['functionType', 'String'], ['isImplicit', 'Bool'],
		['isStatic', 'Bool'], ['isMutating', 'Bool'], ['extendsType', 'String?'],
		['statements', '[Statement]?'], ['access', 'String?']]],
	['class', 'IfStatement',
		[['conditions', '[Expression]'], ['declarations', '[VariableDeclaration]'],
		['statements', '[Statement]'], ['elseStatement', 'IfStatement?'],
		['isGuard', 'Bool']]],
	['struct', 'SwitchCase',
		[['expression', 'Expression?'], ['statements', '[Statement]']]],
	['struct', 'EnumElement',
		[['name', 'String'], ['associatedValues', '[LabeledType]'],
		['annotations', 'String?']]],
	]
}%
%for astElement in astElements:
%	keyword = astElement[0]
%	name = astElement[1]
%	pairs = astElement[2]

public ${keyword} ${name}: Equatable {
%	for pair in pairs:
	var ${pair[0]}: ${pair[1]}
%	end
%	if keyword == 'class':

%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	public init(
		${parametersString})
	{
%		for pair in pairs:
		self.${pair[0]} = ${pair[0]}
%		end
	}

	public static func == (lhs: IfStatement, rhs: IfStatement) -> Bool {
%		equalityChecks = []
%		for pair in pairs:
%			equalityChecks.append("lhs." + pair[0] + " == " + "rhs." + pair[0])
%		end
%		equalityChecksString = " &&\n\t\t\t".join(equalityChecks)
		return ${equalityChecksString}
	}

	public func copy() -> IfStatement {
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t".join(parameters)
		return IfStatement(
			${parametersString})
	}
%	end
}
%end
